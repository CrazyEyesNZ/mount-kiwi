<!-- This updated version replaces checkboxes with per-size quantity inputs like the Mount Kiwi system -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mount Kiwi Example Order</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(to right, #e0eafc, #cfdef3);
      padding: 40px;
    }
    .container {
      display: flex;
      gap: 40px;
      max-width: 1300px;
      margin: auto;
    }
    .order-form {
      flex: 1;
      background: white;
      border-radius: 15px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .order-header {
      padding: 20px;
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 20px;
      font-weight: bold;
    }
    .order-form:first-child .order-header {
      background: linear-gradient(135deg, #667eea, #764ba2);
    }
    .order-form.order-two .order-header {
      background: linear-gradient(135deg, #f093fb, #f5576c);
    }
    .select-btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: bold;
      border: 2px solid white;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .products-container {
      padding: 20px;
      flex: 1;
      overflow-y: auto;
    }
    .product-item {
      padding: 12px;
      margin-bottom: 15px;
      background: #f6f9ff;
      border-radius: 10px;
    }
    .product-name {
      font-weight: bold;
      margin-bottom: 4px;
    }
    .product-description {
      color: #555;
      font-size: 14px;
      margin-bottom: 6px;
    }
    .sizes {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .size-input {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 60px;
    }
    .size-input label {
      font-size: 12px;
      color: #333;
      margin-bottom: 4px;
    }
    .size-input input {
      width: 50px;
      padding: 4px;
      text-align: center;
    }
    .order-summary {
      padding: 15px 20px;
      border-top: 1px solid #eee;
    }
    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .total-row {
      font-weight: bold;
      font-size: 18px;
      color: #667eea;
    }
    .order-form.order-two .total-row {
      color: #f093fb;
    }
    .order-notification {
      background: #f6f9ff;
      border-radius: 10px;
      padding: 30px;
      text-align: center;
      margin: 20px 0;
      border-left: 4px solid #ddd;
    }
    .order-notification.order-1 { border-left-color: #667eea; }
    .order-notification.order-2 { border-left-color: #f093fb; }
    .order-notification.order-3 { border-left-color: #28a745; }
    .order-notification.order-4 { border-left-color: #ffc107; }
    .order-notification.order-5 { border-left-color: #dc3545; }
    .order-notification.order-6 { border-left-color: #17a2b8; }
    .order-notification.order-7 { border-left-color: #6f42c1; }
    .order-notification.order-8 { border-left-color: #e83e8c; }
    .order-notification.order-9 { border-left-color: #20c997; }
    .order-notification.order-10 { border-left-color: #fd7e14; }
    .order-notification .timestamp {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
    }
    .order-notification .accept-btn {
      background: linear-gradient(135deg, #f093fb, #f5576c);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.2s ease;
    }
    .order-notification .accept-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(240, 147, 251, 0.3);
    }
    .order-notification .accept-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .product-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #eee;
    }
    .product-info {
      flex: 1;
    }
    .update-btn {
      background: #6c757d;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .update-btn:hover {
      background: #5a6268;
    }
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .overlay-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      max-width: 700px;
      width: 90%;
      max-height: 80%;
      overflow-y: auto;
    }
    .overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid #eee;
    }
    .overlay-title {
      font-size: 18px;
      font-weight: bold;
      color: #333;
    }
    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .close-btn:hover {
      color: #333;
    }
    .overlay-timestamp {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
      font-style: italic;
    }
    .size-breakdown {
      margin-bottom: 15px;
      overflow-x: auto;
    }
    .breakdown-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 300px;
    }
    .breakdown-table th,
    .breakdown-table td {
      padding: 8px;
      text-align: center;
    }
    .breakdown-table th {
      background: #f8f9fa;
      font-weight: bold;
      font-size: 12px;
    }
    .breakdown-table .row-label {
      background: #f8f9fa;
      font-weight: bold;
      text-align: left;
      min-width: 80px;
    }
    .breakdown-table input[type="number"] {
      width: 60px;
      padding: 4px;
      border: 1px solid #ddd;
      border-radius: 4px;
      text-align: center;
    }
    .breakdown-table input[type="checkbox"] {
      transform: scale(1.2);
    }
    .rejected-input {
      background: #fff5f5;
      border-color: #fecaca;
    }
    .note-section {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #eee;
    }
    .note-label {
      font-weight: bold;
      margin-bottom: 8px;
      color: #333;
    }
    .note-input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
      min-height: 60px;
      font-family: Arial, sans-serif;
    }
    .save-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .accept-btn:disabled {
      background: #ccc !important;
      cursor: not-allowed !important;
      transform: none !important;
      box-shadow: none !important;
    }
    .validation-message {
      color: #dc3545;
      font-size: 12px;
      margin-top: 5px;
      font-style: italic;
    }
    .status-icon {
      margin-left: 4px;
      font-weight: bold;
    }
    .status-complete {
      color: #28a745;
    }
    .status-partial {
      color: #ffc107;
    }
    .completed-qty {
      color: #28a745;
      font-weight: bold;
    }
    .rejected-qty {
      color: #dc3545;
      font-weight: bold;
    }
    .save-btn {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 20px;
      width: 100%;
    }
    .save-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }
    .updates-section {
      border-top: 1px solid #eee;
    }
    .update-entry {
      background: white;
      padding: 8px 12px;
      margin-bottom: 8px;
      border-radius: 6px;
      border-left: 3px solid #667eea;
      font-size: 13px;
    }
    .update-timestamp {
      color: #666;
      font-size: 11px;
      margin-bottom: 4px;
    }
    .update-product {
      font-weight: bold;
      color: #333;
      margin-bottom: 2px;
    }
    .update-details {
      color: #555;
    }
    .order-number {
      color: #000;
      font-weight: bold;
    }
    .update-adding-rejects {
      border-left-color: #dc3545;
      background: #fff5f5;
    }
    .update-fixing-rejects {
      border-left-color: #28a745;
      background: #f8fff8;
    }
    .update-mixed-rejects {
      border-left-color: #ffc107;
      background: #fffbf0;
    }
    .update-standard {
      border-left-color: #667eea;
      background: white;
    }
    .order-1 { border-left-color: #667eea; }
    .order-2 { border-left-color: #f093fb; }
    .order-3 { border-left-color: #28a745; }
    .order-4 { border-left-color: #ffc107; }
    .order-5 { border-left-color: #dc3545; }
    .order-6 { border-left-color: #17a2b8; }
    .order-7 { border-left-color: #6f42c1; }
    .order-8 { border-left-color: #e83e8c; }
    .order-9 { border-left-color: #20c997; }
    .order-10 { border-left-color: #fd7e14; }
    .note-adding-rejects { color: #dc3545; font-weight: bold; }
    .note-fixing-rejects { color: #28a745; font-weight: bold; }
    .note-mixed-rejects { color: #ffc107; font-weight: bold; }
    .note-standard { color: #333; }
    .note-completion { color: #28a745; font-weight: bold; font-style: italic; }
    .note-acceptance { color: #667eea; font-weight: bold; font-style: italic; }
    .size-increase { color: #28a745; font-weight: bold; }
    .size-decrease { color: #dc3545; font-weight: bold; }
    .size-same { color: #333; }
  </style>
</head>
<body>
  <div class="container">
    <!-- NIKKI -->
    <div class="order-form">
      <div class="order-header">
        NIKKI
        <button class="select-btn" onclick="submitOrder()">SUBMIT</button>
      </div>
      <div class="products-container" id="nikki-products">
        <div class="product-item">
          <div class="product-name">Coastal - Charcoal</div>
          <div class="product-description">Sizes</div>
          <div class="sizes">
            <div class="size-input"><label>S</label><input type="number" min="0" data-name="Coastal - Charcoal" data-size="S"></div>
            <div class="size-input"><label>M</label><input type="number" min="0" data-name="Coastal - Charcoal" data-size="M"></div>
            <div class="size-input"><label>L</label><input type="number" min="0" data-name="Coastal - Charcoal" data-size="L"></div>
            <div class="size-input"><label>XL</label><input type="number" min="0" data-name="Coastal - Charcoal" data-size="XL"></div>
          </div>
        </div>

        <div class="product-item">
          <div class="product-name">Byron Bay - Grey</div>
          <div class="product-description">Sizes</div>
          <div class="sizes">
            <div class="size-input"><label>L</label><input type="number" min="0" data-name="Byron Bay - Grey" data-size="L"></div>
            <div class="size-input"><label>XL</label><input type="number" min="0" data-name="Byron Bay - Grey" data-size="XL"></div>
          </div>
        </div>

        <div class="product-item">
          <div class="product-name">House Socks</div>
          <div class="product-description">Sizes</div>
          <div class="sizes">
            <div class="size-input"><label>S/M</label><input type="number" min="0" data-name="House Socks" data-size="S/M"></div>
            <div class="size-input"><label>L</label><input type="number" min="0" data-name="House Socks" data-size="L"></div>
          </div>
        </div>

        <div class="product-item">
          <div class="product-name">Jacket - Alpine</div>
          <div class="product-description">Sizes</div>
          <div class="sizes">
            <div class="size-input"><label>S</label><input type="number" min="0" data-name="Jacket - Alpine" data-size="S"></div>
            <div class="size-input"><label>M</label><input type="number" min="0" data-name="Jacket - Alpine" data-size="M"></div>
            <div class="size-input"><label>L</label><input type="number" min="0" data-name="Jacket - Alpine" data-size="L"></div>
            <div class="size-input"><label>XL</label><input type="number" min="0" data-name="Jacket - Alpine" data-size="XL"></div>
            <div class="size-input"><label>XXL</label><input type="number" min="0" data-name="Jacket - Alpine" data-size="XXL"></div>
            <div class="size-input"><label>3XL</label><input type="number" min="0" data-name="Jacket - Alpine" data-size="3XL"></div>
          </div>
        </div>
      </div>
      <div class="order-summary">
        <div class="summary-row"><span>Selected Items:</span><span id="nikki-count">0</span></div>
        <div class="summary-row"><span>Total:</span><span id="nikki-total">0</span></div>
        <div class="summary-row" id="accepted-timestamp" style="display: none; color: #28a745; font-size: 12px;">
          <span>Accepted:</span><span id="acceptance-time">-</span>
        </div>
      </div>
      <div class="updates-section">
        <div style="padding: 15px 20px; border-top: 1px solid #eee; background: #f8f9fa;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div style="font-weight: bold; color: #667eea; cursor: pointer; text-decoration: underline;" onclick="showAllUpdatesOverlay()">Rita's Updates</div>
            <select id="sort-updates" onchange="updateNikkiUpdatesDisplay()" style="padding: 2px 6px; font-size: 11px; border: 1px solid #ddd; border-radius: 4px;">
              <option value="timestamp">Sort: Latest First</option>
              <option value="order">Sort: Order #</option>
            </select>
          </div>
          <div id="nikki-updates" style="max-height: 200px; overflow-y: auto;">
            <div style="color: #888; font-style: italic; text-align: center; padding: 20px;">No updates yet...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- RITA -->
    <div class="order-form order-two">
      <div class="order-header">
        RITA
        <button class="select-btn" id="acceptOrderBtn" onclick="acceptOrder()" style="display:none;">ACCEPT ORDER</button>
      </div>
      <div class="products-container" id="rita-products">
        <div style="text-align:center; color:#888; padding:60px 20px; font-style:italic;">Waiting for NIKKI to submit order...</div>
      </div>
      <div class="order-summary">
        <div class="summary-row"><span>Selected Items:</span><span id="rita-count">0</span></div>
      </div>
    </div>
  </div>

  <!-- Overlay for updating order details -->
  <div class="overlay" id="updateOverlay">
    <div class="overlay-content">
      <div class="overlay-header">
        <div class="overlay-title" id="overlayTitle">Update Order</div>
        <button class="close-btn" onclick="closeOverlay()">&times;</button>
      </div>
      <div class="overlay-timestamp" id="overlayTimestamp"></div>
      <div id="overlayContent"></div>
      <button class="save-btn" onclick="saveCompletions()" id="save-btn">Save Completions</button>
    </div>
  </div>

  <!-- Overlay for viewing all updates -->
  <div class="overlay" id="allUpdatesOverlay">
    <div class="overlay-content" style="max-width: 600px; max-height: 80%;">
      <div class="overlay-header">
        <div class="overlay-title">All Rita's Updates</div>
        <button class="close-btn" onclick="closeAllUpdatesOverlay()">&times;</button>
      </div>
      <div style="margin-bottom: 15px;">
        <select id="all-updates-sort" onchange="refreshAllUpdatesOverlay()" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="timestamp">Sort: Latest First</option>
          <option value="order">Sort: Order #</option>
        </select>
      </div>
      <div id="allUpdatesContent" style="overflow-y: auto; max-height: 400px;"></div>
    </div>
  </div>

  <!-- Order Details Modal -->
  <div class="overlay" id="orderDetailsModal">
    <div class="overlay-content" style="max-width: 500px;">
      <div class="overlay-header">
        <div class="overlay-title">Order Details</div>
        <button class="close-btn" onclick="closeOrderDetailsModal()">&times;</button>
      </div>
      <div style="margin-bottom: 20px;">
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: bold; margin-bottom: 5px;">Order Name:</label>
          <input type="text" id="orderName" placeholder="Enter order name..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: bold; margin-bottom: 5px;">Shipment Date:</label>
          <input type="date" id="shipmentDate" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <div style="margin-bottom: 20px;">
          <label style="display: block; font-weight: bold; margin-bottom: 5px;">Shipping Method:</label>
          <select id="shippingMethod" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">Select shipping method...</option>
            <option value="SEA">SEA</option>
            <option value="AIR">AIR</option>
          </select>
        </div>
        <div class="validation-message" id="order-validation-message" style="display: none;">
          Please fill in all required fields
        </div>
      </div>
      <button class="save-btn" onclick="confirmOrderSubmission()" id="confirm-order-btn">Submit Order</button>
    </div>
  </div>

  <script>
    let orderCounter = 0;
    let pendingOrderId = null;
    let orderData = {}; // Store order data separately
    let completionData = {}; // Store completion tracking
    let adjustmentData = {}; // Store adjustment tracking
    let acceptedOrders = {}; // Store accepted order data permanently
    let updateHistory = {}; // Store Rita's update history
    let originalAdjustValues = {}; // Track original adjustment values when overlay opens

    // Function to format date to New Zealand standard (DD/MM/YYYY)
    function formatDateToNZ(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString + 'T00:00:00'); // Add time to avoid timezone issues
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    }

    // Add event listeners to update totals in real-time
    document.addEventListener('DOMContentLoaded', function() {
      const inputs = document.querySelectorAll('#nikki-products input[type="number"]');
      inputs.forEach(input => {
        input.addEventListener('input', updateTotals);
      });
    });

    function updateTotals() {
      const inputs = document.querySelectorAll('#nikki-products input[type="number"]');
      let count = 0;

      inputs.forEach(input => {
        const qty = parseInt(input.value, 10) || 0;
        count += qty;
      });

      document.getElementById('nikki-count').textContent = count;
      document.getElementById('nikki-total').textContent = count;
      
      // Also update Rita's count if there's a pending order
      if (pendingOrderId) {
        document.getElementById('rita-count').textContent = count;
        
        // Auto-update the pending order with current values
        const order = {};
        inputs.forEach(input => {
          const qty = parseInt(input.value, 10) || 0;
          if (qty > 0) {
            const name = input.dataset.name;
            const size = input.dataset.size;
            if (!order[name]) order[name] = {};
            order[name][size] = qty;
          }
        });
        
        // Only update if there are items in the order
        if (Object.keys(order).length > 0) {
          const orderTimestamp = new Date().toLocaleString();
          updatePendingOrder(order, orderTimestamp, count);
        }
      }
    }

    function submitOrder() {
      const inputs = document.querySelectorAll('#nikki-products input[type="number"]');
      const order = {};
      let count = 0;

      inputs.forEach(input => {
        const qty = parseInt(input.value, 10) || 0;
        if (qty > 0) {
          const name = input.dataset.name;
          const size = input.dataset.size;
          if (!order[name]) order[name] = {};
          order[name][size] = qty;
          count += qty;
        }
      });

      if (count === 0) {
        alert("Please enter quantities before submitting.");
        return;
      }

      if (pendingOrderId) {
        // If there's already a pending order, just return (auto-updating handles changes)
        return;
      }

      // Show order details modal
      showOrderDetailsModal();
    }

    function showOrderDetailsModal() {
      // Clear previous values
      document.getElementById('orderName').value = '';
      document.getElementById('shipmentDate').value = '';
      document.getElementById('shippingMethod').value = '';
      document.getElementById('order-validation-message').style.display = 'none';
      
      // Show modal
      document.getElementById('orderDetailsModal').style.display = 'flex';
    }

    function closeOrderDetailsModal() {
      document.getElementById('orderDetailsModal').style.display = 'none';
    }

    function confirmOrderSubmission() {
      const orderName = document.getElementById('orderName').value.trim();
      const shipmentDate = document.getElementById('shipmentDate').value;
      const shippingMethod = document.getElementById('shippingMethod').value;
      
      // Validate inputs
      if (!orderName || !shipmentDate || !shippingMethod) {
        document.getElementById('order-validation-message').style.display = 'block';
        return;
      }

      // Hide validation message
      document.getElementById('order-validation-message').style.display = 'none';

      // Get order data
      const inputs = document.querySelectorAll('#nikki-products input[type="number"]');
      const order = {};
      let count = 0;

      inputs.forEach(input => {
        const qty = parseInt(input.value, 10) || 0;
        if (qty > 0) {
          const name = input.dataset.name;
          const size = input.dataset.size;
          if (!order[name]) order[name] = {};
          order[name][size] = qty;
          count += qty;
        }
      });

      const orderTimestamp = new Date().toLocaleString();
      const rita = document.getElementById('rita-products');

      // Create new order
      orderCounter++;
      pendingOrderId = 'order-' + orderCounter;

      // Store order data with additional details
      orderData[pendingOrderId] = {
        order: order,
        timestamp: orderTimestamp,
        orderName: orderName,
        shipmentDate: shipmentDate,
        shippingMethod: shippingMethod
      };

      // If this is the first order, clear the waiting message
      if (orderCounter === 1) {
        rita.innerHTML = '';
      }

      // Create new order notification box
      const orderBox = document.createElement('div');
      orderBox.className = 'order-notification';
      orderBox.id = pendingOrderId;
      orderBox.style.marginBottom = '15px';
      
      // Add order-based border color
      const colorClass = `order-${((orderCounter - 1) % 10) + 1}`;
      orderBox.classList.add(colorClass);
      
      // Format shipment date to NZ format (DD/MM/YYYY)
      const formattedShipDate = formatDateToNZ(shipmentDate);
      
      orderBox.innerHTML = `
        <div class="timestamp">
          <div style="font-weight: bold; margin-bottom: 4px;">${orderName}</div>
          <div style="font-size: 12px; color: #666;">Order #${orderCounter} received: ${orderTimestamp}</div>
          <div style="font-size: 12px; color: #666;">Ship: ${formattedShipDate} via ${shippingMethod}</div>
        </div>
        <button class="accept-btn" onclick="acceptOrder('${pendingOrderId}')" id="acceptBtn-${pendingOrderId}">ACCEPT ORDER</button>
      `;
      rita.appendChild(orderBox);

      // Change submit button text and style
      const submitBtn = document.querySelector('.order-form:first-child .select-btn');
      submitBtn.textContent = 'AUTO UPDATING';
      submitBtn.style.opacity = '0.7';
      submitBtn.style.cursor = 'default';

      document.getElementById('nikki-count').textContent = count;
      document.getElementById('nikki-total').textContent = count;
      document.getElementById('rita-count').textContent = count;

      // Close modal
      closeOrderDetailsModal();
    }

    function updatePendingOrder(order, timestamp, count) {
      const pendingBox = document.getElementById(pendingOrderId);
      const timestampDiv = pendingBox.querySelector('.timestamp');
      
      // Get the stored order details
      const storedData = orderData[pendingOrderId];
      
      // Update stored order data with the new order
      orderData[pendingOrderId] = {
        order: order,
        timestamp: timestamp,
        orderName: storedData.orderName,
        shipmentDate: storedData.shipmentDate,
        shippingMethod: storedData.shippingMethod
      };
      
      // Update timestamp to show it was updated
      const formattedShipDate = formatDateToNZ(storedData.shipmentDate);
      timestampDiv.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 4px;">${storedData.orderName}</div>
        <div style="font-size: 12px; color: #666;">Order #${orderCounter} auto-updated: ${timestamp}</div>
        <div style="font-size: 12px; color: #666;">Ship: ${formattedShipDate} via ${storedData.shippingMethod}</div>
      `;
      
      console.log('Auto-updated order data:', orderData[pendingOrderId]);
    }

    function acceptOrder(orderId) {
      const btn = document.getElementById('acceptBtn-' + orderId);
      btn.textContent = 'COMPLETED';
      btn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
      btn.onclick = () => completeOrder(orderId);

      // Get order data from storage
      const storedData = orderData[orderId];
      const order = storedData.order;
      
      console.log('Accepting order. Stored data:', storedData);
      console.log('Order being accepted:', order);

      // Find the specific notification box
      const notificationBox = document.getElementById(orderId);
      
      // Update the timestamp
      const timestampDiv = notificationBox.querySelector('.timestamp');
      const currentTimestamp = new Date().toLocaleString();
      const storedData2 = orderData[orderId];
      const formattedShipDate = formatDateToNZ(storedData2.shipmentDate);
      
      timestampDiv.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 4px;">${storedData2.orderName}</div>
        <div style="font-size: 12px; color: #666;">Order #${orderCounter} accepted: ${currentTimestamp}</div>
        <div style="font-size: 12px; color: #666;">Ship: ${formattedShipDate} via ${storedData2.shippingMethod}</div>
      `;

      // Add order details to the existing box
      const orderDetails = document.createElement('div');
      orderDetails.style.marginTop = '20px';
      orderDetails.style.textAlign = 'left';

      // Store completion data for this order
      if (!completionData[orderId]) {
        completionData[orderId] = {};
      }

      Object.entries(order).forEach(([name, sizes]) => {
        // Initialize completion tracking for this product
        if (!completionData[orderId][name]) {
          completionData[orderId][name] = {};
          Object.keys(sizes).forEach(size => {
            completionData[orderId][name][size] = 0;
          });
        }

        // Initialize adjustment tracking for this product
        if (!adjustmentData[orderId]) {
          adjustmentData[orderId] = {};
        }
        if (!adjustmentData[orderId][name]) {
          adjustmentData[orderId][name] = {};
          Object.keys(sizes).forEach(size => {
            adjustmentData[orderId][name][size] = 0;
          });
        }

        const item = document.createElement('div');
        item.className = 'product-row';
        item.innerHTML = `
          <div class="product-info">
            <div style="font-weight: bold; margin-bottom: 4px;">${name}</div>
            <div style="color: #555; font-size: 14px;">${Object.entries(sizes).map(([size, qty]) => `${size}(${qty})`).join(', ')}</div>
          </div>
          <button class="update-btn" onclick="showUpdateOverlay('${orderId}', '${name.replace(/'/g, "\\'")}')">UPDATE</button>
        `;
        orderDetails.appendChild(item);
      });

      notificationBox.appendChild(orderDetails);

      // Initialize the order display with status icons
      updateOrderDisplay(orderId);

      // Update complete button state
      updateCompleteButton(orderId);

      // Clear Nikki's form values
      const nikkiInputs = document.querySelectorAll('#nikki-products input[type="number"]');
      nikkiInputs.forEach(input => {
        input.value = '';
      });

      // Reset Nikki's counts and allow new orders
      document.getElementById('nikki-count').textContent = '0';
      document.getElementById('nikki-total').textContent = '0';
      pendingOrderId = null;
      
      // Reset submit button to normal state
      const submitBtn = document.querySelector('.order-form:first-child .select-btn');
      submitBtn.textContent = 'SUBMIT';
      submitBtn.style.opacity = '1';
      submitBtn.style.cursor = 'pointer';

      // Show acceptance timestamp for Nikki
      document.getElementById('accepted-timestamp').style.display = 'flex';
      document.getElementById('acceptance-time').textContent = currentTimestamp;

      // Store accepted order data and clean up pending data
      acceptedOrders[orderId] = storedData;
      delete orderData[orderId];

      // Add acceptance update to Rita's Updates
      const acceptanceTimestamp = new Date().toLocaleString() + ' - Order accepted and ready for processing';
      const orderNumber = orderId.replace('order-', '');
      
      if (!updateHistory[orderId]) {
        updateHistory[orderId] = [];
      }
      
      // Add single acceptance entry for the whole order
      updateHistory[orderId].push({
        timestamp: acceptanceTimestamp,
        orderNumber: orderNumber,
        isAcceptance: true, // Special flag for acceptance updates
        isOrderLevel: true // Flag to indicate this is an order-level update, not product-specific
      });
      
      // Update Nikki's updates section
      updateNikkiUpdatesDisplay();
    }

    function completeOrder(orderId) {
      // Check if order is actually complete before allowing completion
      if (!checkOrderComplete(orderId)) {
        alert('Cannot complete order: some items are not fully completed.');
        return;
      }

      const notificationBox = document.getElementById(orderId);
      
      // Find and hide the order details and button
      const orderDetails = notificationBox.querySelector('div[style*="marginTop"]');
      const completedBtn = document.getElementById('acceptBtn-' + orderId);
      
      if (orderDetails) orderDetails.style.display = 'none';
      if (completedBtn) completedBtn.style.display = 'none';
      
      // Update the box styling to show it's completed
      notificationBox.style.background = '#f8f9fa';
      notificationBox.style.border = '1px solid #dee2e6';
      notificationBox.style.padding = '10px 20px';
      
      // Update timestamp to show completed
      const timestampDiv = notificationBox.querySelector('.timestamp');
      timestampDiv.textContent = timestampDiv.textContent.replace('accepted:', 'completed:');
      timestampDiv.style.fontSize = '12px';
      timestampDiv.style.color = '#6c757d';
      timestampDiv.style.fontStyle = 'italic';

      // Hide acceptance timestamp for Nikki since order is completed
      document.getElementById('accepted-timestamp').style.display = 'none';

      // Add completion update to Rita's Updates
      const timestamp = new Date().toLocaleString() + ' - Order completed successfully';
      const orderNumber = orderId.replace('order-', '');
      
      if (!updateHistory[orderId]) {
        updateHistory[orderId] = [];
      }
      
      // Add single completion entry for the whole order
      updateHistory[orderId].push({
        timestamp: timestamp,
        orderNumber: orderNumber,
        isCompletion: true, // Special flag for completion updates
        isOrderLevel: true // Flag to indicate this is an order-level update, not product-specific
      });
      
      // Update Nikki's updates section
      updateNikkiUpdatesDisplay();
    }

    // Overlay functions
    let currentOverlayOrderId = null;
    let currentOverlayProduct = null;
    let originalRejectValues = {}; // Track original reject values when overlay opens

    function showUpdateOverlay(orderId, productName) {
      currentOverlayOrderId = orderId;
      currentOverlayProduct = productName;
      
      // Get the accepted order data and completion data
      const orderInfo = acceptedOrders[orderId];
      const productSizes = orderInfo ? orderInfo.order[productName] : {};
      const completions = completionData[orderId][productName] || {};
      const adjustments = adjustmentData[orderId] && adjustmentData[orderId][productName] ? adjustmentData[orderId][productName] : {};
      const timestamp = orderInfo ? orderInfo.timestamp : '';
      
      // Store original adjustment values for comparison
      originalAdjustValues = {};
      previousAdjustValues = {};
      Object.keys(productSizes).forEach(size => {
        const adjustValue = adjustments[size] || 0;
        originalAdjustValues[size] = adjustValue;
        previousAdjustValues[size] = adjustValue; // Also track for immediate changes
      });
      
      // Update overlay content
      document.getElementById('overlayTitle').textContent = productName;
      const formattedShipDate = orderInfo ? formatDateToNZ(orderInfo.shipmentDate) : '';
      const orderDetails = orderInfo ? 
        `${orderInfo.orderName} - Order time: ${orderInfo.timestamp} - Ship: ${formattedShipDate} via ${orderInfo.shippingMethod}` : 
        `Order time: ${timestamp}`;
      document.getElementById('overlayTimestamp').textContent = orderDetails;
      
      const overlayContent = document.getElementById('overlayContent');
      overlayContent.innerHTML = '';
      
      // Create transposed table
      const breakdown = document.createElement('div');
      breakdown.className = 'size-breakdown';
      
      const sizes = Object.keys(productSizes);
      
      const table = document.createElement('table');
      table.className = 'breakdown-table';
      
      // Header row with sizes
      const headerRow = document.createElement('tr');
      headerRow.innerHTML = '<th></th>' + sizes.map(size => `<th>${size}</th>`).join('');
      table.appendChild(headerRow);
      
      // Ordered row
      const orderedRow = document.createElement('tr');
      orderedRow.innerHTML = '<td class="row-label">Ordered</td>' + 
        sizes.map(size => `<td>${productSizes[size]}</td>`).join('');
      table.appendChild(orderedRow);
      
      // Completed row
      const completedRow = document.createElement('tr');
      completedRow.innerHTML = '<td class="row-label">Completed</td>' + 
        sizes.map(size => `<td><input type="number" class="completed-input" min="0" max="${productSizes[size]}" 
               value="${completions[size] || 0}" data-size="${size}" onchange="validateSave(); updateCheckbox('${size}', ${productSizes[size]})"></td>`).join('');
      table.appendChild(completedRow);
      
      // Adjusted row
      const adjustedRow = document.createElement('tr');
      adjustedRow.innerHTML = '<td class="row-label">Adjusted</td>' + 
        sizes.map(size => `<td><input type="number" class="adjusted-input" max="0" 
               value="${adjustments[size] || 0}" data-size="${size}" data-type="adjusted" onchange="handleAdjustChange('${size}'); validateSave()"></td>`).join('');
      table.appendChild(adjustedRow);
      
      // Checkbox row
      const checkboxRow = document.createElement('tr');
      checkboxRow.innerHTML = '<td class="row-label">Complete</td>' + 
        sizes.map(size => {
          const completed = completions[size] || 0;
          const isComplete = completed >= productSizes[size];
          return `<td><input type="checkbox" class="completion-checkbox" ${isComplete ? 'checked' : ''} 
                 onchange="handleCheckboxChange('${size}', ${productSizes[size]})" data-size="${size}"></td>`;
        }).join('');
      table.appendChild(checkboxRow);
      
      breakdown.appendChild(table);
      overlayContent.appendChild(breakdown);
      
      // Add note section
      const noteSection = document.createElement('div');
      noteSection.className = 'note-section';
      noteSection.innerHTML = `
        <div style="font-size: 12px; color: #666; margin-bottom: 10px; font-style: italic;">
          Note: Adding adjustments will automatically reduce completed quantities. Fixing adjustments will increase them.
        </div>
        <div class="note-label">Notes:</div>
        <textarea class="note-input" id="update-note" placeholder="Add notes about this update (required when adding/fixing adjustments)..." oninput="validateSave()"></textarea>
        <div class="validation-message" id="validation-message" style="display: none;">
          Note required when adding new adjustments or fixing existing adjustments
        </div>
      `;
      overlayContent.appendChild(noteSection);
      
      // Show overlay and validate initially
      document.getElementById('updateOverlay').style.display = 'flex';
      validateSave();
    }

    function closeOverlay() {
      document.getElementById('updateOverlay').style.display = 'none';
      currentOverlayOrderId = null;
      currentOverlayProduct = null;
      originalAdjustValues = {}; // Clear original values
      previousAdjustValues = {}; // Clear previous values
    }

    function saveCompletions() {
      if (!currentOverlayOrderId || !currentOverlayProduct) return;
      
      const completedInputs = document.querySelectorAll('.completed-input');
      const adjustedInputs = document.querySelectorAll('.adjusted-input');
      const noteInput = document.getElementById('update-note');
      
      const updates = {};
      const adjustments = {};
      let adjustmentsHaveChanged = false;
      let adjustmentChangeDetails = [];
      
      // Process completed quantities
      completedInputs.forEach(input => {
        const size = input.dataset.size;
        const completed = parseInt(input.value) || 0;
        completionData[currentOverlayOrderId][currentOverlayProduct][size] = completed;
        updates[size] = completed;
      });
      
      // Process adjusted quantities and track changes
      adjustedInputs.forEach(input => {
        const size = input.dataset.size;
        const adjusted = parseInt(input.value) || 0;
        const originalAdjusted = originalAdjustValues[size] || 0;
        
        adjustmentData[currentOverlayOrderId][currentOverlayProduct][size] = adjusted;
        
        if (adjusted !== originalAdjusted) {
          adjustmentsHaveChanged = true;
          
          if (adjusted < originalAdjusted) {
            // More adjustments added
            const newAdjustments = originalAdjusted - adjusted;
            adjustmentChangeDetails.push(`${size}: +${newAdjustments} new adjustments`);
          } else if (adjusted > originalAdjusted) {
            // Adjustments fixed/removed
            const fixedAdjustments = adjusted - originalAdjusted;
            adjustmentChangeDetails.push(`${size}: fixed ${fixedAdjustments} adjustments`);
          }
        }
        
        if (adjusted < 0) {
          adjustments[size] = adjusted;
        }
      });
      
      // Validate note requirement for adjustment changes
      if (adjustmentsHaveChanged && !noteInput.value.trim()) {
        return; // Should not reach here due to button disable, but safety check
      }
      
      // Create timestamp with note if provided
      let timestamp = new Date().toLocaleString();
      if (noteInput.value.trim()) {
        timestamp += ` - ${noteInput.value.trim()}`;
      }
      
      // Store update history
      if (!updateHistory[currentOverlayOrderId]) {
        updateHistory[currentOverlayOrderId] = [];
      }
      
      const updateEntry = {
        timestamp: timestamp,
        product: currentOverlayProduct,
        updates: updates,
        orderNumber: currentOverlayOrderId.replace('order-', ''),
        adjustmentChanges: adjustmentsHaveChanged ? adjustmentChangeDetails : null
      };
      
      // Only include adjustments in history if there are current negative values
      if (Object.keys(adjustments).length > 0) {
        updateEntry.adjustments = adjustments;
      }
      
      updateHistory[currentOverlayOrderId].push(updateEntry);
      
      // Update the main order display with status icons
      updateOrderDisplay(currentOverlayOrderId);
      
      // Update complete button state
      updateCompleteButton(currentOverlayOrderId);
      
      // Update Nikki's updates section
      updateNikkiUpdatesDisplay();
      
      closeOverlay();
    }

    function validateSave() {
      const adjustedInputs = document.querySelectorAll('.adjusted-input');
      const noteInput = document.getElementById('update-note');
      const saveBtn = document.getElementById('save-btn');
      const validationMessage = document.getElementById('validation-message');
      
      let adjustmentsHaveChanged = false;
      
      // Check if any adjustment values have changed from their original values
      adjustedInputs.forEach(input => {
        const size = input.dataset.size;
        const currentValue = parseInt(input.value) || 0;
        const originalValue = originalAdjustValues[size] || 0;
        
        if (currentValue !== originalValue) {
          adjustmentsHaveChanged = true;
        }
      });
      
      const hasNote = noteInput && noteInput.value.trim().length > 0;
      
      if (adjustmentsHaveChanged && !hasNote) {
        saveBtn.disabled = true;
        validationMessage.style.display = 'block';
      } else {
        saveBtn.disabled = false;
        validationMessage.style.display = 'none';
      }
    }

    function checkOrderComplete(orderId) {
      const orderInfo = acceptedOrders[orderId];
      if (!orderInfo) return false;

      // Check each product and size to see if all are fully completed
      for (const [productName, sizes] of Object.entries(orderInfo.order)) {
        for (const [size, required] of Object.entries(sizes)) {
          const completed = completionData[orderId] && completionData[orderId][productName] 
            ? (completionData[orderId][productName][size] || 0) : 0;
          
          if (completed < required) {
            return false; // Not all items are complete
          }
        }
      }
      return true; // All items are complete
    }

    function updateCompleteButton(orderId) {
      const completeBtn = document.getElementById('acceptBtn-' + orderId);
      if (!completeBtn) return;

      const isOrderComplete = checkOrderComplete(orderId);
      
      if (isOrderComplete) {
        completeBtn.disabled = false;
        completeBtn.style.opacity = '1';
        completeBtn.style.cursor = 'pointer';
        completeBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
        completeBtn.textContent = 'COMPLETED';
      } else {
        completeBtn.disabled = true;
        completeBtn.style.opacity = '0.6';
        completeBtn.style.cursor = 'not-allowed';
        completeBtn.style.background = '#ccc';
        completeBtn.textContent = 'PENDING COMPLETION';
      }
    }

    function getCompletionStatus(orderId, productName, size) {
      if (!completionData[orderId] || !completionData[orderId][productName]) return 'none';
      
      const completed = completionData[orderId][productName][size] || 0;
      const adjusted = adjustmentData[orderId] && adjustmentData[orderId][productName] ? (adjustmentData[orderId][productName][size] || 0) : 0;
      const ordered = acceptedOrders[orderId].order[productName][size];
      
      // Effective completion is completed items (adjustments reduce the total available)
      // If we have adjustments, they've already been subtracted from completed count
      if (completed >= ordered) return 'complete';
      if (completed > 0 || adjusted < 0) return 'partial';
      return 'none';
    }

    function updateCheckbox(size, maxQty) {
      const input = document.querySelector(`.completed-input[data-size="${size}"]`);
      const checkbox = document.querySelector(`.completion-checkbox[data-size="${size}"]`);
      if (input && checkbox) {
        const currentValue = parseInt(input.value) || 0;
        checkbox.checked = currentValue >= maxQty;
      }
    }

    function handleCheckboxChange(size, orderQty) {
      const checkbox = document.querySelector(`.completion-checkbox[data-size="${size}"]`);
      const input = document.querySelector(`.completed-input[data-size="${size}"]`);
      
      if (checkbox && input) {
        if (checkbox.checked) {
          input.value = orderQty;
        } else {
          input.value = Math.min(parseInt(input.value) || 0, orderQty - 1);
        }
        validateSave();
      }
    }

    function handleAdjustChange(size) {
      const adjustedInput = document.querySelector(`.adjusted-input[data-size="${size}"]`);
      const completedInput = document.querySelector(`.completed-input[data-size="${size}"]`);
      
      if (!adjustedInput || !completedInput) return;
      
      const currentAdjusted = parseInt(adjustedInput.value) || 0;
      const previousAdjusted = previousAdjustValues[size] || 0;
      
      // Calculate how many adjustments changed from the previous value
      const adjustedDifference = currentAdjusted - previousAdjusted;
      
      // Get current completed value
      let currentCompleted = parseInt(completedInput.value) || 0;
      
      // If adjustments increased (more negative), reduce completed
      // If adjustments decreased (less negative), increase completed
      const newCompleted = currentCompleted + adjustedDifference;
      
      // Ensure completed doesn't go below 0 or above ordered quantity
      const orderedQty = parseInt(completedInput.getAttribute('max'));
      const finalCompleted = Math.max(0, Math.min(orderedQty, newCompleted));
      
      completedInput.value = finalCompleted;
      
      // Update the previous value for next change
      previousAdjustValues[size] = currentAdjusted;
      
      // Update checkbox state
      updateCheckbox(size, orderedQty);
      
      console.log(`Adjustment change for ${size}: previous=${previousAdjusted}, current=${currentAdjusted}, difference=${adjustedDifference}, completed: ${currentCompleted} -> ${finalCompleted}`);
    }

    function updateOrderDisplay(orderId) {
      const orderBox = document.getElementById(orderId);
      if (!orderBox) return;
      
      const productRows = orderBox.querySelectorAll('.product-row');
      productRows.forEach(row => {
        const productInfo = row.querySelector('.product-info');
        const productNameEl = productInfo.querySelector('div:first-child');
        const productName = productNameEl.textContent;
        const sizesEl = productInfo.querySelector('div:last-child');
        
        if (acceptedOrders[orderId] && acceptedOrders[orderId].order[productName]) {
          const sizes = acceptedOrders[orderId].order[productName];
          const sizeText = Object.entries(sizes).map(([size, qty]) => {
            const completed = completionData[orderId] && completionData[orderId][productName] ? (completionData[orderId][productName][size] || 0) : 0;
            const adjusted = adjustmentData[orderId] && adjustmentData[orderId][productName] ? (adjustmentData[orderId][productName][size] || 0) : 0;
            
            let sizeDisplay = `${size}(${qty})`;
            
            // Add completed quantity in green
            if (completed > 0) {
              sizeDisplay += `<span class="completed-qty">[${completed}]</span>`;
            }
            
            // Add adjusted quantity in red (show as positive number)
            if (adjusted < 0) {
              sizeDisplay += `<span class="adjusted-qty">[${Math.abs(adjusted)}]</span>`;
            }
            
            // Add status icon
            const status = getCompletionStatus(orderId, productName, size);
            if (status === 'complete') sizeDisplay += '<span class="status-icon status-complete"></span>';
            else if (status === 'partial') sizeDisplay += '<span class="status-icon status-partial"></span>';
            
            return sizeDisplay;
          }).join(', ');
          
          sizesEl.innerHTML = sizeText;
        }
      });
    }

    // Close overlay when clicking outside
    document.getElementById('updateOverlay').addEventListener('click', function(e) {
      if (e.target === this) {
        closeOverlay();
      }
    });

    // Close all updates overlay when clicking outside
    document.getElementById('allUpdatesOverlay').addEventListener('click', function(e) {
      if (e.target === this) {
        closeAllUpdatesOverlay();
      }
    });

    // Close order details modal when clicking outside
    document.getElementById('orderDetailsModal').addEventListener('click', function(e) {
      if (e.target === this) {
        closeOrderDetailsModal();
      }
    });

    function renderUpdatesList(updates, container) {
      container.innerHTML = '';
      
      // Track previous values for each order/product/size combination
      const previousValues = {};
      
      // Process updates in chronological order to track changes
      const chronologicalUpdates = [...updates].sort((a, b) => {
        const timeA = new Date(a.timestamp.split(' - ')[0]);
        const timeB = new Date(b.timestamp.split(' - ')[0]);
        return timeA - timeB; // Oldest first for tracking
      });
      
      // Build the tracking data with position indices (exclude completion, acceptance, and order-level updates from change tracking)
      const changeTracking = {};
      chronologicalUpdates.filter(update => !update.isCompletion && !update.isAcceptance && !update.isOrderLevel).forEach((update, chronoIndex) => {
        const key = `${update.orderId}-${update.product}`;
        if (!changeTracking[key]) {
          changeTracking[key] = {};
        }
        
        Object.entries(update.updates).forEach(([size, qty]) => {
          if (!changeTracking[key][size]) {
            changeTracking[key][size] = [];
          }
          changeTracking[key][size].push({
            value: qty,
            updateId: `${update.timestamp}-${update.product}-${size}` // Unique identifier
          });
        });
      });
      
      // Now render in the requested order
      updates.forEach((update, index) => {
        const updateEl = document.createElement('div');
        updateEl.className = 'update-entry';
        
        // Add order-based border color
        const orderNum = parseInt(update.orderNumber);
        const colorClass = `order-${((orderNum - 1) % 10) + 1}`;
        updateEl.classList.add(colorClass);
        
        // Handle order-level updates (acceptance/completion) differently
        if (update.isOrderLevel) {
          // Get order info for header
          const orderInfo = acceptedOrders[update.orderId];
          const formattedShipDate = orderInfo ? formatDateToNZ(orderInfo.shipmentDate) : '';
          const orderHeader = orderInfo ? 
            `Order #${update.orderNumber} - ${orderInfo.orderName} - ${orderInfo.shippingMethod} - ${formattedShipDate}` :
            `Order #${update.orderNumber}`;
          
          // Determine note class
          let noteClass = 'note-standard';
          if (update.isCompletion) {
            noteClass = 'note-completion';
          } else if (update.isAcceptance) {
            noteClass = 'note-acceptance';
          }
          
          // Extract note from timestamp and apply color
          const timestampParts = update.timestamp.split(' - ');
          const baseTimestamp = timestampParts[0];
          const noteText = timestampParts.length > 1 ? timestampParts.slice(1).join(' - ') : '';
          
          updateEl.innerHTML = `
            <div class="update-timestamp">${baseTimestamp}${noteText ? ` - <span class="${noteClass}">${noteText}</span>` : ''}</div>
            <div class="update-product"><span class="order-number">${orderHeader}</span></div>
            <div class="update-details">${noteText}</div>
          `;
          
          container.appendChild(updateEl);
          return; // Skip the rest of the processing for order-level updates
        }
        
        // Rest of the existing logic for product-specific updates...
        // Get the original order data to show required quantities
        const orderInfo = acceptedOrders[update.orderId];
        const productSizes = orderInfo && orderInfo.order[update.product] ? orderInfo.order[update.product] : {};
        
        // Format the order header with order details
        const formattedShipDate = orderInfo ? formatDateToNZ(orderInfo.shipmentDate) : '';
        const orderHeader = orderInfo ? 
          `Order #${update.orderNumber} - ${orderInfo.orderName} - ${orderInfo.shippingMethod} - ${formattedShipDate}` :
          `Order #${update.orderNumber}`;
        
        // Build completed details with same format as Rita's orders
        const key = `${update.orderId}-${update.product}`;
        const completedDetails = Object.entries(productSizes)
          .map(([size, required]) => {
            const completed = update.updates[size] || 0;
            
            // Get current adjustment data for this order/product/size
            const currentAdjusted = adjustmentData[update.orderId] && 
                                  adjustmentData[update.orderId][update.product] && 
                                  adjustmentData[update.orderId][update.product][size] 
                                  ? Math.abs(adjustmentData[update.orderId][update.product][size]) : 0;
            
            // Skip if no activity on this size
            if (completed === 0 && currentAdjusted === 0) return null;
            
            // Determine if this is an increase, decrease, or same for change indicators
            let changeClass = 'size-same';
            
            // Don't show change indicators for completion, acceptance, or order-level updates
            if (!update.isCompletion && !update.isAcceptance && !update.isOrderLevel) {
              const updateId = `${update.timestamp}-${update.product}-${size}`;
              
              if (changeTracking[key] && changeTracking[key][size]) {
                const sizeHistory = changeTracking[key][size];
                const currentUpdateIndex = sizeHistory.findIndex(item => item.updateId === updateId);
                
                if (currentUpdateIndex > 0) {
                  const previousQty = sizeHistory[currentUpdateIndex - 1].value;
                  if (completed > previousQty) {
                    changeClass = 'size-increase';
                  } else if (completed < previousQty) {
                    changeClass = 'size-decrease';
                  }
                } else if (currentUpdateIndex === 0 && completed > 0) {
                  // First entry and greater than 0 = increase from nothing
                  changeClass = 'size-increase';
                }
              } else if (completed > 0) {
                // No previous history and greater than 0 = increase from nothing
                changeClass = 'size-increase';
              }
            }
            
            // Build display same as Rita's orders
            let sizeDisplay = `${size}(${required})`;
            
            // Add completed quantity in green (with change indicator)
            if (completed > 0) {
              sizeDisplay += `<span class="completed-qty ${changeClass}">[${completed}]</span>`;
            }
            
            // Add adjusted quantity in red
            if (currentAdjusted > 0) {
              sizeDisplay += `<span class="adjusted-qty">[${currentAdjusted}]</span>`;
            }
            
            // Add status icon
            if (completed >= required) {
              sizeDisplay += '<span class="status-icon status-complete"></span>';
            } else if (completed > 0 || currentAdjusted > 0) {
              sizeDisplay += '<span class="status-icon status-partial"></span>';
            }
            
            return sizeDisplay;
          })
          .filter(item => item !== null)
          .join(', ');
        
        let detailsText = '';
        if (completedDetails) detailsText += `Status: ${completedDetails}`;
        
        // Determine note text color and adjustment info
        let noteClass = 'note-standard';
        let hasNewAdjustments = false;
        let hasFixedAdjustments = false;
        
        // Check if this is a completion update
        if (update.isCompletion) {
          noteClass = 'note-completion';
        } else if (update.isAcceptance) {
          noteClass = 'note-acceptance'; // Use specific styling for acceptance
        } else if (update.adjustmentChanges && update.adjustmentChanges.length > 0) {
          if (detailsText) detailsText += '; ';
          
          // Analyze adjustment changes to determine note color
          update.adjustmentChanges.forEach(change => {
            if (change.includes('new adjustments')) {
              hasNewAdjustments = true;
            } else if (change.includes('fixed')) {
              hasFixedAdjustments = true;
            }
          });
          
          // Determine note color
          if (hasNewAdjustments && hasFixedAdjustments) {
            noteClass = 'note-mixed-adjustments';
          } else if (hasNewAdjustments) {
            noteClass = 'note-adding-adjustments';
          } else if (hasFixedAdjustments) {
            noteClass = 'note-fixing-adjustments';
          }
          
          detailsText += update.adjustmentChanges.join(', ');
        } else if (update.adjustments || update.rejections) {
          // Fallback for older updates (handle both adjustments and legacy rejections)
          const legacyData = update.adjustments || update.rejections;
          const adjustedDetails = Object.entries(legacyData)
            .filter(([size, qty]) => qty < 0)
            .map(([size, qty]) => `${size}(${Math.abs(qty)})`)
            .join(', ');
          
          if (adjustedDetails) {
            if (detailsText) detailsText += '; ';
            detailsText += `Adjustments: ${adjustedDetails}`;
            noteClass = 'note-adding-adjustments';
          }
        }
        
        // Extract note from timestamp and apply color
        const timestampParts = update.timestamp.split(' - ');
        const baseTimestamp = timestampParts[0];
        const noteText = timestampParts.length > 1 ? timestampParts.slice(1).join(' - ') : '';
        
        updateEl.innerHTML = `
          <div class="update-timestamp">${baseTimestamp}${noteText ? ` - <span class="${noteClass}">${noteText}</span>` : ''}</div>
          <div class="update-product"><span class="order-number">${orderHeader}</span></div>
          <div class="update-details">${update.product} ${detailsText}</div>
        `;
        
        container.appendChild(updateEl);
      });
    }

    function showAllUpdatesOverlay() {
      document.getElementById('allUpdatesOverlay').style.display = 'flex';
      refreshAllUpdatesOverlay();
    }

    function closeAllUpdatesOverlay() {
      document.getElementById('allUpdatesOverlay').style.display = 'none';
    }

    function refreshAllUpdatesOverlay() {
      const container = document.getElementById('allUpdatesContent');
      const sortBy = document.getElementById('all-updates-sort').value;
      
      // Add legend at the top
      container.innerHTML = `
        <div class="legend-section" style="margin-bottom: 15px;">
          <div class="legend-title">Legend:</div>
          <div class="legend-grid">
            <span class="legend-item">
              <span class="legend-sample status-complete"></span>
              <span class="legend-text">Fully done</span>
            </span>
            <span class="legend-item">
              <span class="legend-sample status-partial"></span>
              <span class="legend-text">Partial</span>
            </span>
            <span class="legend-item">
              <span class="legend-sample size-increase">[4]</span>
              <span class="legend-text">Increased</span>
            </span>
            <span class="legend-item">
              <span class="legend-sample size-decrease">[2]</span>
              <span class="legend-text">Decreased</span>
            </span>
          </div>
        </div>
      `;
      
      // Get all updates
      const allUpdates = [];
      Object.entries(updateHistory).forEach(([orderId, updates]) => {
        updates.forEach(update => {
          allUpdates.push({...update, orderId});
        });
      });
      
      // Sort based on selection
      if (sortBy === 'timestamp') {
        // Sort by actual timestamp, most recent first
        allUpdates.sort((a, b) => {
          const timeA = new Date(a.timestamp.split(' - ')[0]);
          const timeB = new Date(b.timestamp.split(' - ')[0]);
          return timeB - timeA; // Most recent first
        });
      } else if (sortBy === 'order') {
        allUpdates.sort((a, b) => {
          const orderNumA = parseInt(a.orderNumber);
          const orderNumB = parseInt(b.orderNumber);
          if (orderNumA !== orderNumB) {
            return orderNumA - orderNumB;
          }
          // Within same order, sort by timestamp (earliest first)
          const timeA = new Date(a.timestamp.split(' - ')[0]);
          const timeB = new Date(b.timestamp.split(' - ')[0]);
          return timeA - timeB;
        });
      }
      
      if (allUpdates.length === 0) {
        const noUpdatesDiv = document.createElement('div');
        noUpdatesDiv.style.cssText = 'color: #888; font-style: italic; text-align: center; padding: 40px;';
        noUpdatesDiv.textContent = 'No updates yet...';
        container.appendChild(noUpdatesDiv);
        return;
      }
      
      // Create a container for the updates list
      const updatesContainer = document.createElement('div');
      renderUpdatesList(allUpdates, updatesContainer);
      container.appendChild(updatesContainer);
    }

    function updateNikkiUpdatesDisplay() {
      const updatesContainer = document.getElementById('nikki-updates');
      const sortBy = document.getElementById('sort-updates').value;
      
      // Get all updates
      const allUpdates = [];
      Object.entries(updateHistory).forEach(([orderId, updates]) => {
        updates.forEach(update => {
          allUpdates.push({...update, orderId});
        });
      });
      
      // Sort based on selection
      if (sortBy === 'timestamp') {
        // Sort by actual timestamp, most recent first
        allUpdates.sort((a, b) => {
          const timeA = new Date(a.timestamp.split(' - ')[0]); // Remove note part for date parsing
          const timeB = new Date(b.timestamp.split(' - ')[0]);
          return timeB - timeA; // Most recent first
        });
      } else if (sortBy === 'order') {
        allUpdates.sort((a, b) => {
          const orderNumA = parseInt(a.orderNumber);
          const orderNumB = parseInt(b.orderNumber);
          if (orderNumA !== orderNumB) {
            return orderNumA - orderNumB;
          }
          // Within same order, sort by timestamp (earliest first)
          const timeA = new Date(a.timestamp.split(' - ')[0]);
          const timeB = new Date(b.timestamp.split(' - ')[0]);
          return timeA - timeB;
        });
      }
      
      if (allUpdates.length === 0) {
        updatesContainer.innerHTML = '<div style="color: #888; font-style: italic; text-align: center; padding: 20px;">No updates yet...</div>';
        return;
      }
      
      // Show the last 5 updates
      const recentUpdates = allUpdates.slice(0, 5);
      
      renderUpdatesList(recentUpdates, updatesContainer);
      
      // Add "view more" indicator if there are more than 5 updates
      if (allUpdates.length > 5) {
        const moreEl = document.createElement('div');
        moreEl.style.textAlign = 'center';
        moreEl.style.color = '#666';
        moreEl.style.fontSize = '11px';
        moreEl.style.fontStyle = 'italic';
        moreEl.style.marginTop = '10px';
        moreEl.style.cursor = 'pointer';
        moreEl.style.textDecoration = 'underline';
        moreEl.textContent = `... click "Rita's Updates" to see all ${allUpdates.length} updates`;
        moreEl.onclick = showAllUpdatesOverlay;
        updatesContainer.appendChild(moreEl);
      }
    }
  </script>
</body>
</html>
